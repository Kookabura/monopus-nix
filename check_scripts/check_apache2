#!/bin/bash

#   This program is free software; you can redistribute it and/or modify
#   it under the terms of the GNU General Public License as published by
#   the Free Software Foundation; either version 2 of the License, or
#   (at your option) any later version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU General Public License for more details.
#
#   You should have received a copy of the GNU General Public License
#   along with this program; if not, write to the Free Software
#   Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

PROGNAME=$(basename "$0")
VERSION="Version 1.3,"
AUTHOR="2009, Mike Adolphs (http://www.matejunkie.com/)"

print_version() {
    echo "$VERSION $AUTHOR"
}

print_help() {
    print_version "$PROGNAME $VERSION"
    echo ""
    echo "Description:"
    echo "$PROGNAME is a Nagios plugin to check the Apache's server status."
    echo "It monitors requests per second, bytes per second/request, "
    echo "amount of busy/idle workers and its CPU load."
    echo ""
    echo "Example call:"
    echo "./$PROGNAME -H localhost -P 80 -t 3 -b /usr/sbin -p /var/run \\"
    echo "-n apache2.pid -s status_page [-S] [-R] [-wr] 100 [-cr] 250"
    echo ""
    echo "Options:"
    echo "  -H|--hostname)"
    echo "    Sets the hostname. Default is: localhost"
    echo "  -P|--port)"
    echo "    Sets the port. Default is: 80"
    echo "  -t|--timeout)"
    echo "    Sets a timeout within the server's status page must've been"
    echo "    accessed. Otherwise the check will go into an error state."
    echo "    Default is: 3"
    echo "  -b|--binary-path)"
    echo "    Sets the path to the apache binary. Used for getting Apache's"
    echo "    CPU load. Default is: /usr/sbin"
    echo "  -p|--pid-path)"
    echo "    Path to Apache's pid file. Default is: /var/run"
    echo "  -n|--pid-name)"
    echo "    Name of Apache's pid file. Default is: apache2.pid"
    echo "  -s|--status-page)"
    echo "    Defines the name of the status page. Default is: server-status"
    echo "  -R|--remote-server)"
    echo "    Disabled the pid check so that remote Apaches can be queried."
    echo "    Default is: off"
    echo "  -S|--secure)"
    echo "    Enables HTTPS (no certificate check though). Default is: off"
    echo "  -wr|--warning-req)"
    echo "    Sets a warning level for requests per second. Default is: off"
    echo "  -cr|--critical-req)"
    echo "    Sets a critical level for requests per second. Default is: off"
    exit $ST_UK
}

ST_OK=0
ST_WR=1
ST_CR=2
ST_UK=3

hostname="localhost"
port=80
remote_srv=0
path_binary="/usr/sbin"
path_pid="/var/run"
name_pid="apache2.pid"
status_page="server-status"
timeout=3
secure=0
running=0
process="httpd"

wcdiff_req=0
wclvls_req=0

while [ -n "$1" ]; do
    case "$1" in
        --help|-h)
            print_help
            ;;
        --version|-v)
            print_version "$PROGNAME $VERSION"
            exit "$ST_UK"
            ;;
        --hostname|-H)
            hostname=$2
            shift
            ;;
        --port|-P)
            port=$2
            shift
            ;;
        --timeout|-t)
            timeout=$2
            shift
            ;;
        --remote-server|-R)
            remote_srv=1
            ;;
        --binary_path|-b)
            path_binary=$2
            shift
            ;;
        --pid_path|-p)
            path_pid=$2
            shift
            ;;
        --pid_name|-n)
            name_pid=$2
            shift
            ;;
        --status-page|-s)
            status_page=$2
            shift
            ;;
        --secure|-S)
            secure=1
            ;;
        --warning-req|-wr)
            warn_req=$2
            shift
            ;;
        --critical-req|-cr)
            crit_req=$2
            shift
            ;;
        *)
            echo "Unknown argument: $1"
            print_help
            ;;
    esac
    shift
done

# check functions
val_wcdiff_req() {
    if [ -n "$warn_req" ] && [ -n "$crit_req" ]
    then
        wclvls_req=1
        if [ "$warn_req" -gt "$crit_req" ]
        then
            wcdiff_req=1
        fi
    elif [ -n "$warn_req" ] && [ -z "$crit_req" ]
    then
        wcdiff_req=2
    elif [ -z "$warn_req" ] && [ -n "$crit_req" ]
    then
        wcdiff_req=3
    fi
}

check_pid() {
    if [ -f "$path_pid/$name_pid" ]
    then
        retval=0
    else
        retval=1
    fi
}

check_processes() {
    if [ "$1" -lt 1 ]; then
        echo "UNKNOWN - Your Apache server seems not to run. Is your Nagios privileged to run 'ps ax' and is the Apache2 binary really located in $path_binary?"
        exit "$ST_UK"
    fi
}

check_output() {
    stat_output=$(stat -c %s ${output_dir}/server-status)
    if [ "$stat_output" = 0 ]
    then
        echo "UNKNOWN - Local copy of server-status is empty. Are we allowed to access http://${hostname}:${port}/server-status?"
        exit $ST_UK
    fi
}

# get status page server and save her in /tmp/server_status
get_status() {
    if [ "$secure" = 1 ]                            # if https
    then
        if [ -e /tmp/server_status ];
        then
            status_prev=$(cat /tmp/server_status)
        else
            status_prev=""
        fi
        status_cur=$(wget -qO- --no-check-certificate -t 3 -T "${timeout}" "https://${hostname}:${port}/${status_page}?auto")
    else                                            # if http
        if [ -e /tmp/server_status ];
        then
            status_prev=$(cat /tmp/server_status)
        else
            status_prev=""
        fi
        status_cur=$(wget -qO- -t 3 -T "${timeout}" "http://${hostname}:${port}/${status_page}?auto")
    fi
    echo "$status_cur" > /tmp/server_status         # save web statistic apache in temp file
}
# collection of web server statistics
get_vals() {
    # save cpu statistic for pidstat in tmp 
    sh /opt/monopus/check_scripts/pidstat.sh $process &
    # cpu load calculaite through pidstat in packet sysstat
    cpu_load=0
	if [ -s /tmp/${process}_2min_stat.txt ] # if file exist and not empty
    then
        stat="$(cat /tmp/${process}_2min_stat.txt)"
        cpu_load=$(echo "$stat" | tr "[:space:]" '+')
        cpu_load=$(echo "$cpu_load" | sed 's/.$//' | bc -l | awk '{printf "%.1f", $0}')
    fi
    if [ -s /tmp/server_status ]            # if file exist and not empty
    then 
        # requests per second
        taccess1=$(echo "${status_prev}" | head -n1 | awk '{print $3}')
        taccess2=$(echo "${status_cur}" | head -n1 | awk '{print $3}')
        uptime1=$(echo "${status_prev}" | head -n4 | tail -n1 | awk '{print $2}')
        uptime2=$(echo "${status_cur}" | head -n4 | tail -n1 | awk '{print $2}')
        ((req = taccess2 - taccess1))
        ((uptime = uptime2 - uptime1))
        req_psec=$(echo "scale=2; (${req}) / (${uptime})" | bc -l | awk '{printf "%.2f", $0}')
        # bytes per second
        kb1=$(echo "${status_prev}" | head -n2 | tail -n1 | awk '{print $3}')
        kb2=$(echo "${status_cur}" | head -n2 | tail -n1 | awk '{print $3}')
        ((kb = kb2 - kb1))
        #kb_psec=$(echo "scale=2; ${kb} / ${uptime}" | bc -l | awk '{printf "%.2f", $0}')
        mbs_psec=$(echo "scale=3; (${kb} / ${uptime}) / 1024" | bc -l | awk '{printf "%.3f", $0}')
        # bytes per request
        #kb_preq=$(echo "${kb} / ${req}" | bc -l | awk '{printf "%.2f", $0}')
        mbs_preq=$(echo "scale=3; (${kb} / ${req}) / 1024" | bc -l | awk '{printf "%.3f", $0}')
        # busy workers
        wkrs_busy=$(echo "${status_cur}" | head -n8 | tail -n1 | awk '{print $2}')
        # idle workers
        wkrs_idle=$(echo "${status_cur}" | head -n9 | tail -n1 | awk '{print $2}')
    else                                # if /tmp/server_status not exist - return empty metrics
        req_psec=0
        mbs_psec=0
        mbs_preq=0
        wkrs_busy=0
        wkrs_idle=0
    fi
}

do_output() {
    output="req_psec==${req_psec}__cpu_load==${cpu_load}__wkrs_busy==${wkrs_busy}__wkrs_idle==${wkrs_idle}"
}

do_perfdata() {
    perfdata="cpu_load=${cpu_load};;;; req_psec=${req_psec};;;; workers_busy=${wkrs_busy};;;; workers_idle=${wkrs_idle};;;; bytes_psec=${mbs_psec};;;; bytes_preq=${mbs_preq};;;;" 
}

# Check value warnings/criticals thresholds
val_wcdiff_req

if [ "$wcdiff_req" = 1 ]
then
    echo "Please adjust your warning/critical thresholds. The warning must \
be lower than the critical level!"
    exit $ST_UK
elif [ "$wcdiff_req" = 2 ]
then
    echo "Please also set a critical value when you want to use \
warning/critical thresholds!"
    exit $ST_UK
elif [ "$wcdiff_req" = 3 ]
then
    echo "Please also set a warning value when you want to use \
warning/critical thresholds!"
    exit $ST_UK
else
    if [ "$remote_srv" = 0 ]
    then
        running=$(check_pid)
        check_pid "$running"
    fi
    # check exists process "httpd" or "apache2" in system
    if [ "$(pgrep -c "httpd")" -gt 0 ]
    then
        process="httpd"
    elif [ "$(pgrep -c "apache2")" -gt 0 ]
    then
        process="apache2"
    fi

    get_status
    get_vals

    do_output
    do_perfdata

    if [ ${wclvls_req} = 1 ]
    then
        if [ "${req_psec}" -ge "${warn_req}" ] && [ "${req_psec}" -lt "${crit_req}" ]
        then
            echo "check_apache2.warning::${output}|${perfdata}"
            exit $ST_WR
        elif [ "${req_psec}" -ge "${crit_req}" ]
        then
            echo "check_apache2.critical::${output}|${perfdata}"
            exit $ST_CR
        else
            echo "check_apache2.ok::${output}|${perfdata}"
            exit $ST_OK
        fi
    else
        echo "check_apache2.ok::${output}|${perfdata}"
        exit $ST_OK
    fi

fi